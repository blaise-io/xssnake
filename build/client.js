/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n\n\n//# sourceURL=webpack://xssnake/./node_modules/events/events.js?");

/***/ }),

/***/ "./server/const.ts":
/*!*************************!*\
  !*** ./server/const.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SERVER_MAX_TOLERATED_LATENCY = exports.SERVER_TICK_INTERVAL = exports.GAME_TOP = exports.GAME_LEFT = void 0;\ntrue = false;\nexports.GAME_LEFT = 0;\nexports.GAME_TOP = 0;\nexports.SERVER_TICK_INTERVAL = 1000 / 20;\nexports.SERVER_MAX_TOLERATED_LATENCY = 150;\n\n\n//# sourceURL=webpack://xssnake/./server/const.ts?");

/***/ }),

/***/ "./server/game/serverSnake.ts":
/*!************************************!*\
  !*** ./server/game/serverSnake.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ServerSnake = void 0;\nconst const_1 = __webpack_require__(/*! ../../shared/const */ \"./shared/const.ts\");\nconst snakeMove_1 = __webpack_require__(/*! ../../shared/game/snakeMove */ \"./shared/game/snakeMove.ts\");\nconst snake_1 = __webpack_require__(/*! ../../shared/snake */ \"./shared/snake.ts\");\nclass ServerSnake extends snake_1.Snake {\n    constructor(index, level) {\n        super(index, level);\n        this.index = index;\n        this.level = level;\n        this.elapsed = 0;\n    }\n    destruct() {\n        this.level = null;\n    }\n    serialize() {\n        return [this.index, this.direction, this.parts];\n    }\n    handleNextMove(tick, elapsed, shift, players) {\n        this.elapsed += elapsed;\n        if (!this.crashed && this.elapsed >= this.speed) {\n            const move = new snakeMove_1.SnakeMove(this, players, this.level, this.getNextPosition());\n            this.elapsed -= this.speed;\n            if (!move.collision) {\n                this.collision = null;\n                this.move(move.location);\n            }\n            else if (!this.collision) {\n                this.collision = move.collision;\n                this.collision.tick = tick;\n            }\n        }\n    }\n    getNextPosition() {\n        const head = this.getHead();\n        const shift = const_1.GAME_SHIFT_MAP[this.direction];\n        return [head[0] + shift[0], head[1] + shift[1]];\n    }\n    hasCollisionLteTick(tick) {\n        return !this.crashed && this.collision && this.collision.tick <= tick;\n    }\n}\nexports.ServerSnake = ServerSnake;\n\n\n//# sourceURL=webpack://xssnake/./server/game/serverSnake.ts?");

/***/ }),

/***/ "./server/index.ts":
/*!*************************!*\
  !*** ./server/index.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst server_1 = __webpack_require__(/*! ./netcode/server */ \"./server/netcode/server.ts\");\nnew server_1.Server();\n\n\n//# sourceURL=webpack://xssnake/./server/index.ts?");

/***/ }),

/***/ "./server/netcode/heartbeat.ts":
/*!*************************************!*\
  !*** ./server/netcode/heartbeat.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ServerHeartbeat = void 0;\n/**\n * @param {room.ServerPlayer} player\n * @constructor\n */\nconst const_1 = __webpack_require__(/*! ../../shared/const */ \"./shared/const.ts\");\nconst const_2 = __webpack_require__(/*! ../const */ \"./server/const.ts\");\nclass ServerHeartbeat {\n    constructor(player) {\n        this.player = player;\n        this.latency = 0;\n        this.pingSent = 0;\n        this.bindEvents();\n    }\n    destruct() {\n        this.player.emitter.removeAllListeners([const_1.NC_PING, const_1.NC_PONG]);\n        this.player = null;\n    }\n    isAlive() {\n        const pingSent = this.pingSent || +new Date();\n        return +new Date() - pingSent < const_1.HEARTBEAT_INTERVAL_MS * 2;\n    }\n    bindEvents() {\n        this.player.emitter.on(const_1.NC_PING, this.ping.bind(this));\n        this.player.emitter.on(const_1.NC_PONG, this.pong.bind(this));\n    }\n    ping() {\n        this.pingSent = +new Date();\n        this.player.emit(const_1.NC_PONG);\n    }\n    pong() {\n        this.latency = Math.min(const_2.SERVER_MAX_TOLERATED_LATENCY, (+new Date() - this.pingSent) / 2);\n    }\n}\nexports.ServerHeartbeat = ServerHeartbeat;\n\n\n//# sourceURL=webpack://xssnake/./server/netcode/heartbeat.ts?");

/***/ }),

/***/ "./server/netcode/server.ts":
/*!**********************************!*\
  !*** ./server/netcode/server.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Server = void 0;\nconst config_1 = __webpack_require__(/*! ../../shared/config */ \"./shared/config.ts\");\nconst roomManager_1 = __webpack_require__(/*! ../room/roomManager */ \"./server/room/roomManager.ts\");\nconst ws_1 = __webpack_require__(/*! ws */ \"./node_modules/ws/lib/browser.js\");\nconst events_1 = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\nconst serverPlayer_1 = __webpack_require__(/*! ../room/serverPlayer */ \"./server/room/serverPlayer.ts\");\nclass Server {\n    constructor() {\n        this.emitter = new events_1.EventEmitter();\n        this.roomManager = new roomManager_1.ServerRoomManager(this);\n        this.ws = this.start();\n    }\n    destruct() {\n        this.roomManager.destruct();\n        this.roomManager = null;\n        this.ws.close();\n    }\n    start() {\n        const ws = new ws_1.Server({\n            host: config_1.SERVER_HOST,\n            port: config_1.SERVER_PORT,\n            path: config_1.SERVER_PATH,\n        });\n        ws.on(\"connection\", (connection) => {\n            new serverPlayer_1.ServerPlayer(this, connection);\n        });\n        return ws;\n    }\n}\nexports.Server = Server;\n\n\n//# sourceURL=webpack://xssnake/./server/netcode/server.ts?");

/***/ }),

/***/ "./server/room/roomManager.ts":
/*!************************************!*\
  !*** ./server/room/roomManager.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ServerRoomManager = void 0;\n/**\n * @param {netcode.Server} server\n * @constructor\n */\nclass ServerRoomManager {\n    constructor(ServerRoomManager) {\n        this.server = server;\n        /** @type {Array.<room.ServerRoom>} */\n        this.rooms = [];\n        this.matcher = new Matcher(this.rooms);\n        this.bindEvents();\n    }\n    destruct() {\n        this.removeAllRooms();\n        this.matcher.destruct();\n        this.server.emitter.removeAllListeners([\n            NC_ROOM_STATUS,\n            NC_ROOM_JOIN_KEY,\n            NC_ROOM_JOIN_MATCHING,\n        ]);\n    }\n    bindEvents() {\n        const emitter = this.server.emitter;\n        emitter.on(NC_ROOM_STATUS, this.emitRoomStatus.bind(this));\n        emitter.on(NC_ROOM_JOIN_KEY, this.autojoinRoom.bind(this));\n        emitter.on(NC_ROOM_JOIN_MATCHING, this.joinMatchingRoom.bind(this));\n    }\n    /**\n     * @param {string} key\n     * @return {room.ServerRoom}\n     */\n    room(key) {\n        return this.rooms[key];\n    }\n    /**\n     * @param {room.ServerRoom} room\n     */\n    remove(room) {\n        room.destruct();\n        for (let i = 0, m = this.rooms.length; i < m; i++) {\n            if (room === this.rooms[i]) {\n                this.rooms.splice(i, 1);\n            }\n        }\n    }\n    removeAllRooms() {\n        for (let i = 0, m = this.rooms.length; i < m; i++) {\n            this.rooms[i].destruct();\n        }\n        this.rooms.length = 0;\n    }\n    /**\n     * @param {room.ServerOptions} preferences\n     * @return {room.ServerRoom}\n     */\n    createRoom(preferences) {\n        let room;\n        const id = randomStr(ROOM_KEY_LENGTH);\n        room = new ServerRoom(this.server, preferences, id);\n        this.rooms.push(room);\n        return room;\n    }\n    /**\n     * @param {Array.<?>} dirtyKeyArr\n     * @param {room.ServerPlayer} player\n     */\n    autojoinRoom(dirtyKeyArr, player) {\n        let room;\n        let key;\n        let status;\n        key = this.getSanitizedRoomKey(dirtyKeyArr);\n        status = this.getRoomStatus(key);\n        if (status === ROOM_JOINABLE) {\n            room = this.getRoomByKey(key);\n            room.addPlayer(player);\n            player.emit(NC_ROUND_SERIALIZE, room.rounds.round.serialize());\n            room.detectAutostart();\n        }\n        else {\n            player.emit(NC_ROOM_JOIN_ERROR, [status]);\n        }\n    }\n    /**\n     * @param {Array.<?>} dirtySerializeOptions\n     * @param {room.ServerPlayer} player\n     * @private\n     */\n    joinMatchingRoom(dirtySerializeOptions, player) {\n        let options;\n        let room;\n        let emitDataArr;\n        emitDataArr = new Sanitizer(dirtySerializeOptions).assertArray().getValueOr([]);\n        options = new ServerOptions(emitDataArr);\n        room = this.matcher.getRoomMatching(options);\n        room = room || this.createRoom(options);\n        room.addPlayer(player);\n        room.emitAll(player);\n        room.detectAutostart();\n    }\n    getRoomByKey(key) {\n        for (let i = 0, m = this.rooms.length; i < m; i++) {\n            if (key === this.rooms[i].key) {\n                return this.rooms[i];\n            }\n        }\n        return null;\n    }\n    getSanitizedRoomKey(dirtyKeyArr) {\n        const keySanitizer = new Sanitizer(dirtyKeyArr[0]);\n        keySanitizer.assertStringOfLength(ROOM_KEY_LENGTH);\n        return keySanitizer.getValueOr();\n    }\n    /**\n     * @param {string} key\n     * @return {number}\n     */\n    getRoomStatus(key) {\n        let room;\n        if (!key) {\n            return ROOM_INVALID_KEY;\n        }\n        room = this.getRoomByKey(key);\n        if (!room) {\n            return ROOM_NOT_FOUND;\n        }\n        else if (room.isFull()) {\n            return ROOM_FULL;\n        }\n        else if (room.rounds.hasStarted()) {\n            return ROOM_IN_PROGRESS;\n        }\n        return ROOM_JOINABLE;\n    }\n    /**\n     * @param {Array.<?>} dirtyKeyArr\n     * @param {room.ServerPlayer} player\n     */\n    emitRoomStatus(dirtyKeyArr, player) {\n        let room;\n        let key;\n        let status;\n        key = this.getSanitizedRoomKey(dirtyKeyArr);\n        status = this.getRoomStatus(key);\n        if (status === ROOM_JOINABLE) {\n            room = this.getRoomByKey(key);\n            player.emit(NC_ROOM_SERIALIZE, room.serialize());\n            player.emit(NC_OPTIONS_SERIALIZE, room.options.serialize());\n            player.emit(NC_PLAYERS_SERIALIZE, room.players.serialize());\n        }\n        else {\n            player.emit(NC_ROOM_JOIN_ERROR, [status]);\n        }\n    }\n}\nexports.ServerRoomManager = ServerRoomManager;\n\n\n//# sourceURL=webpack://xssnake/./server/room/roomManager.ts?");

/***/ }),

/***/ "./server/room/serverPlayer.ts":
/*!*************************************!*\
  !*** ./server/room/serverPlayer.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ServerPlayer = void 0;\nconst const_1 = __webpack_require__(/*! ../../shared/const */ \"./shared/const.ts\");\nconst player_1 = __webpack_require__(/*! ../../shared/room/player */ \"./shared/room/player.ts\");\nconst events_1 = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\nconst util_1 = __webpack_require__(/*! ../../shared/util */ \"./shared/util.ts\");\nconst sanitizer_1 = __webpack_require__(/*! ../../shared/util/sanitizer */ \"./shared/util/sanitizer.ts\");\nconst serverSnake_1 = __webpack_require__(/*! ../game/serverSnake */ \"./server/game/serverSnake.ts\");\nconst heartbeat_1 = __webpack_require__(/*! ../netcode/heartbeat */ \"./server/netcode/heartbeat.ts\");\nclass ServerPlayer extends player_1.Player {\n    constructor(server, connection) {\n        super();\n        this.server = server;\n        this.connection = connection;\n        this.emitter = new events_1.EventEmitter();\n        this.room = null;\n        this.connection.on(\"message\", this.onmessage.bind(this));\n        this.connection.on(\"close\", this.onclose.bind(this));\n        this.connected = true;\n        this.bindEvents();\n        this.heartbeat = new heartbeat_1.ServerHeartbeat(this);\n    }\n    destruct() {\n        if (this.connected) {\n            this.disconnect();\n        }\n        this.unbindEvents();\n        this.heartbeat.destruct(); // Awww.\n        this.server = null;\n        this.snake = null;\n        this.room = null;\n        this.heartbeat = null;\n    }\n    disconnect() {\n        this.connected = false;\n        if (this.snake) {\n            this.snake.crashed = true;\n            this.room.emitter.emit(const_1.SE_PLAYER_COLLISION, [this]);\n        }\n        this.emitMessage(const_1.SE_PLAYER_DISCONNECT, this);\n        if (this.connection) {\n            this.connection.close();\n            this.connection = null;\n        }\n        this.emitter.removeAllListeners();\n    }\n    /**\n     * @param {string} jsonStr\n     */\n    onmessage(jsonStr) {\n        const message = new netcode.Message(jsonStr);\n        console.log(\"IN \", this.name, jsonStr);\n        if (message.isClean) {\n            this.emitMessage(message.event, message.data);\n        }\n    }\n    emitMessage(event, data) {\n        let playerEmits, roomEmits;\n        playerEmits = this.emitter.emit(event, data);\n        roomEmits = this.room && this.room.emitter.emit(event, data, this);\n        // Global events (connecting, finding room).\n        if (!playerEmits && !roomEmits) {\n            this.server.emitter.emit(event, data, this);\n        }\n    }\n    onclose() {\n        if (this.room && this.room.rounds && this.room.rounds.hasStarted()) {\n            // Cannot destruct immediately, game expects player.\n            // Room should destruct player at end of round, or\n            // when all players in room have disconnected.\n            this.disconnect();\n        }\n        else {\n            this.destruct();\n        }\n    }\n    bindEvents() {\n        this.emitter.on(const_1.NC_PLAYER_NAME, this.setName.bind(this));\n    }\n    unbindEvents() {\n        this.emitter.removeAllListeners(const_1.NC_PLAYER_NAME);\n    }\n    /**\n     * @param {?} dirtyNameArr\n     * @return {string}\n     */\n    setName(dirtyNameArr) {\n        this.name = new sanitizer_1.Sanitizer(dirtyNameArr[0])\n            .assertStringOfLength(const_1.PLAYER_NAME_MINLENGTH, 20)\n            .getValueOr(util_1.getRandomName());\n        return this.name;\n    }\n    /**\n     * Send data to client\n     * @param {number} event\n     * @param {Array.<string|number|Array>=} data\n     */\n    emit(event, data) {\n        let emit;\n        if (!this.connected) {\n            return false;\n        }\n        else if (!this.heartbeat.isAlive()) {\n            this.disconnect();\n            return false;\n        }\n        else if (this.connection) {\n            if (data) {\n                emit = data.slice();\n                emit.unshift(event);\n            }\n            else {\n                emit = [event];\n            }\n            console.log(\"OUT\", this.name, JSON.stringify(emit));\n            this.connection.send(JSON.stringify(emit), function (error) {\n                if (error) {\n                    console.error(\"Error sending message\", error);\n                }\n            }.bind(this));\n        }\n    }\n    /**\n     * @param {string} type\n     * @param {*=} data\n     */\n    broadcast(type, data) {\n        if (this.room) {\n            this.room.players.emit(type, data, this);\n        }\n    }\n    /**\n     * @param {number} index\n     * @param {level.Level} level\n     */\n    setSnake(index, level) {\n        this.snake = new serverSnake_1.ServerSnake(index, level);\n    }\n    unsetSnake() {\n        if (this.snake) {\n            this.snake.destruct();\n        }\n    }\n    /**\n     * @return {number}\n     */\n    getMaxMismatchesAllowed() {\n        const latency = Math.min(const_1.NETCODE_SYNC_MS, this.heartbeat.latency);\n        return Math.ceil(latency / this.snake.speed);\n    }\n}\nexports.ServerPlayer = ServerPlayer;\n\n\n//# sourceURL=webpack://xssnake/./server/room/serverPlayer.ts?");

/***/ }),

/***/ "./shared/config.ts":
/*!**************************!*\
  !*** ./shared/config.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SERVER_ENDPOINT = exports.SERVER_PATH = exports.SERVER_PORT = exports.SERVER_HOST = void 0;\nexports.SERVER_HOST = \"127.0.0.1\";\nexports.SERVER_PORT = 8001;\nexports.SERVER_PATH = \"\";\nexports.SERVER_ENDPOINT = exports.SERVER_HOST + \":\" + exports.SERVER_PORT + exports.SERVER_PATH;\n\n\n//# sourceURL=webpack://xssnake/./shared/config.ts?");

/***/ }),

/***/ "./shared/const.ts":
/*!*************************!*\
  !*** ./shared/const.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SPAWN_CHANCE_APPLE = exports.SPAWN_SOMETHING_EVERY = exports.SECONDS_ROUND_COUNTDOWN = exports.SECONDS_ROUNDSET_GLOAT = exports.SECONDS_ROUND_GLOAT = exports.SECONDS_ROUND_PAUSE = exports.PLAYER_NAME_MAXWIDTH = exports.PLAYER_NAME_MINLENGTH = exports.ROOM_WIN_BY_MIN = exports.ROUNDS_MAX = exports.ROOM_CAPACITY = exports.ROOM_KEY_LENGTH = exports.DIRECTION_DOWN = exports.DIRECTION_RIGHT = exports.DIRECTION_UP = exports.DIRECTION_LEFT = exports.GAME_SHIFT_MAP = exports.HEARTBEAT_INTERVAL_MS = exports.SE_PLAYER_COLLISION = exports.SE_PLAYER_DISCONNECT = exports.NC_XSS = exports.NC_SNAKE_UPDATE = exports.NC_SNAKE_SPEED = exports.NC_SNAKE_SIZE = exports.NC_SNAKE_CRASH = exports.NC_SNAKE_ACTION = exports.NC_SCORE_UPDATE = exports.NC_ROUND_WRAPUP = exports.NC_ROUND_START = exports.NC_ROUND_COUNTDOWN = exports.NC_ROUND_SERIALIZE = exports.NC_OPTIONS_SERIALIZE = exports.NC_ROOM_JOIN_ERROR = exports.NC_ROOM_STATUS = exports.NC_ROOM_START = exports.NC_ROOM_SERIALIZE = exports.NC_ROOM_JOIN_MATCHING = exports.NC_ROOM_JOIN_KEY = exports.NC_PLAYERS_SERIALIZE = exports.NC_PLAYER_NAME = exports.NC_PONG = exports.NC_PING = exports.NC_GAME_SPAWN = exports.NC_GAME_STATE = exports.NC_GAME_DESPAWN = exports.NC_CHAT_MESSAGE = exports.NC_CHAT_NOTICE = exports.GAME_TILE = exports.HEIGHT = exports.WIDTH = void 0;\nexports.NOTICE_NEW_ROUND = exports.NOTICE_DISCONNECT = exports.NOTICE_JOIN = exports.NOTICE_CRASH = exports.SPAWN_POWERUP = exports.SPAWN_APPLE = exports.SCORE_BEHIND = exports.SCORE_NEUTRAL = exports.SCORE_LEADING = exports.VALIDATE_ERR_MISMATCHES = exports.VALIDATE_ERR_NO_COMMON = exports.VALIDATE_ERR_GAP = exports.VALIDATE_SUCCES = exports.NETCODE_SYNC_MS = exports.NETCODE_PING_INTERVAL = exports.CRASH_OPPONENT_DRAW = exports.CRASH_OPPONENT = exports.CRASH_SELF = exports.CRASH_MOVING_WALL = exports.CRASH_WALL = exports.CRASH_UNKNOWN = exports.ROOM_UNKNOWN_ERROR = exports.ROOM_IN_PROGRESS = exports.ROOM_NOT_FOUND = exports.ROOM_FULL = exports.ROOM_INVALID_KEY = exports.ROOM_JOINABLE = exports.FIELD_VALUE_HARD = exports.FIELD_VALUE_MEDIUM = exports.FIELD_VALUE_EASY = exports.SNAKE_SIZE = exports.SNAKE_SPEED = void 0;\nexports.WIDTH = 256;\nexports.HEIGHT = 161;\nexports.GAME_TILE = 4;\n// Netcode events\nexports.NC_CHAT_NOTICE = 10;\nexports.NC_CHAT_MESSAGE = 11;\nexports.NC_GAME_DESPAWN = 20;\nexports.NC_GAME_STATE = 21;\nexports.NC_GAME_SPAWN = 22;\nexports.NC_PING = 0;\nexports.NC_PONG = 1;\nexports.NC_PLAYER_NAME = 30;\nexports.NC_PLAYERS_SERIALIZE = 31;\nexports.NC_ROOM_JOIN_KEY = 40;\nexports.NC_ROOM_JOIN_MATCHING = 41;\nexports.NC_ROOM_SERIALIZE = 42;\nexports.NC_ROOM_START = 43;\nexports.NC_ROOM_STATUS = 44;\nexports.NC_ROOM_JOIN_ERROR = 45;\nexports.NC_OPTIONS_SERIALIZE = 47;\nexports.NC_ROUND_SERIALIZE = 50;\nexports.NC_ROUND_COUNTDOWN = 51;\nexports.NC_ROUND_START = 52;\nexports.NC_ROUND_WRAPUP = 53;\nexports.NC_SCORE_UPDATE = 60;\nexports.NC_SNAKE_ACTION = 70;\nexports.NC_SNAKE_CRASH = 71;\nexports.NC_SNAKE_SIZE = 72;\nexports.NC_SNAKE_SPEED = 73;\nexports.NC_SNAKE_UPDATE = 74;\nexports.NC_XSS = 666;\n// Server EventEmitters\nexports.SE_PLAYER_DISCONNECT = 101;\nexports.SE_PLAYER_COLLISION = 102;\nexports.HEARTBEAT_INTERVAL_MS = 5000;\nexports.GAME_SHIFT_MAP = [\n    [-1, 0],\n    [0, -1],\n    [1, 0],\n    [0, 1],\n];\nexports.DIRECTION_LEFT = 0;\nexports.DIRECTION_UP = 1;\nexports.DIRECTION_RIGHT = 2;\nexports.DIRECTION_DOWN = 3;\nexports.ROOM_KEY_LENGTH = 5;\nexports.ROOM_CAPACITY = 6;\nexports.ROUNDS_MAX = 3;\nexports.ROOM_WIN_BY_MIN = 2;\nexports.PLAYER_NAME_MINLENGTH = 1;\nexports.PLAYER_NAME_MAXWIDTH = 36;\nexports.SECONDS_ROUND_PAUSE = 3;\nexports.SECONDS_ROUND_GLOAT = 5;\nexports.SECONDS_ROUNDSET_GLOAT = 10;\nexports.SECONDS_ROUND_COUNTDOWN = 3;\nexports.SPAWN_SOMETHING_EVERY = [20, 60];\nexports.SPAWN_CHANCE_APPLE = 0.9;\nexports.SNAKE_SPEED = 120;\nexports.SNAKE_SIZE = 4;\nexports.FIELD_VALUE_EASY = 1;\nexports.FIELD_VALUE_MEDIUM = 2;\nexports.FIELD_VALUE_HARD = 3;\nexports.ROOM_JOINABLE = 1;\nexports.ROOM_INVALID_KEY = 2;\nexports.ROOM_FULL = 3;\nexports.ROOM_NOT_FOUND = 4;\nexports.ROOM_IN_PROGRESS = 5;\nexports.ROOM_UNKNOWN_ERROR = 6;\nexports.CRASH_UNKNOWN = 0;\nexports.CRASH_WALL = 1;\nexports.CRASH_MOVING_WALL = 2;\nexports.CRASH_SELF = 3;\nexports.CRASH_OPPONENT = 4;\nexports.CRASH_OPPONENT_DRAW = 5;\nexports.NETCODE_PING_INTERVAL = 3000;\nexports.NETCODE_SYNC_MS = 500;\nexports.VALIDATE_SUCCES = 0;\nexports.VALIDATE_ERR_GAP = 1;\nexports.VALIDATE_ERR_NO_COMMON = 2;\nexports.VALIDATE_ERR_MISMATCHES = 3;\nexports.SCORE_LEADING = 1;\nexports.SCORE_NEUTRAL = 2;\nexports.SCORE_BEHIND = 3;\nexports.SPAWN_APPLE = 1;\nexports.SPAWN_POWERUP = 2;\nexports.NOTICE_CRASH = 1;\nexports.NOTICE_JOIN = 2;\nexports.NOTICE_DISCONNECT = 3;\nexports.NOTICE_NEW_ROUND = 4;\n\n\n//# sourceURL=webpack://xssnake/./shared/const.ts?");

/***/ }),

/***/ "./shared/game/collision.ts":
/*!**********************************!*\
  !*** ./shared/game/collision.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Collision = void 0;\n/**\n * @param {Coordinate} part\n * @param {number} into\n * @constructor\n */\nclass Collision {\n    constructor(location, into) {\n        this.location = location;\n        this.into = into;\n        this.tick = 0;\n    }\n    serialize() {\n        return this.location;\n    }\n}\nexports.Collision = Collision;\n\n\n//# sourceURL=webpack://xssnake/./shared/game/collision.ts?");

/***/ }),

/***/ "./shared/game/snakeMove.ts":
/*!**********************************!*\
  !*** ./shared/game/snakeMove.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SnakeMove = void 0;\nconst const_1 = __webpack_require__(/*! ../const */ \"./shared/const.ts\");\nconst collision_1 = __webpack_require__(/*! ./collision */ \"./shared/game/collision.ts\");\nclass SnakeMove {\n    constructor(snake, players, level, location) {\n        this.snake = snake;\n        this.players = players;\n        this.level = level;\n        this.location = location;\n        this.collision = this.getCollission();\n    }\n    getParts(part) {\n        const parts = this.snake.parts.slice();\n        parts.unshift();\n        parts.push(part);\n        return parts;\n    }\n    getCollission() {\n        const parts = this.getParts(this.location);\n        for (let i = 0, m = parts.length; i < m; i++) {\n            const collision = this.getCollisionPart(i, parts[i]);\n            if (collision) {\n                return collision;\n            }\n        }\n        return null;\n    }\n    getCollisionPart(index, part) {\n        let players;\n        let levelData;\n        let partIndex;\n        players = this.players;\n        levelData = this.level.data;\n        if (index > 4) {\n            partIndex = this.snake.getPartIndex(part);\n            if (-1 !== partIndex && index !== partIndex) {\n                return new collision_1.Collision(part, const_1.CRASH_SELF);\n            }\n        }\n        if (levelData.isWall(part[0], part[1])) {\n            return new collision_1.Collision(part, const_1.CRASH_WALL);\n        }\n        if (levelData.isMovingWall(part)) {\n            return new collision_1.Collision(part, const_1.CRASH_MOVING_WALL);\n        }\n        for (let i = 0, m = players.length; i < m; i++) {\n            const opponentSnake = players[i].snake;\n            if (opponentSnake.crashed === false &&\n                opponentSnake !== this.snake &&\n                opponentSnake.hasPart(part)) {\n                return new collision_1.Collision(part, const_1.CRASH_OPPONENT);\n            }\n        }\n        return null;\n    }\n}\nexports.SnakeMove = SnakeMove;\n\n\n//# sourceURL=webpack://xssnake/./shared/game/snakeMove.ts?");

/***/ }),

/***/ "./shared/room/player.ts":
/*!*******************************!*\
  !*** ./shared/room/player.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Player = void 0;\nclass Player {\n    constructor(name = \"\") {\n        this.name = name;\n        this.connected = false;\n        this.score = 0;\n        this.snake = null;\n    }\n    deserialize(serialized) {\n        let byte;\n        [this.name, byte] = serialized;\n        this.connected = Boolean((byte & 1) >> 0);\n        this.local = Boolean((byte & 2) >> 1);\n        this.score = byte >> 2;\n    }\n    serialize(local) {\n        return [\n            this.name,\n            (Number(this.connected) << 0) | (Number(local) << 1) | (this.score << 2),\n        ];\n    }\n}\nexports.Player = Player;\n\n\n//# sourceURL=webpack://xssnake/./shared/room/player.ts?");

/***/ }),

/***/ "./shared/snake.ts":
/*!*************************!*\
  !*** ./shared/snake.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Snake = void 0;\nclass Snake {\n    constructor(index, level) {\n        this.index = index;\n        const spawn = level.data.spawns[index];\n        /** Head is last in array */\n        this.parts = [spawn.location];\n        this.direction = spawn.direction;\n        this.size = level.config.snakeSize;\n        this.speed = level.config.snakeSpeed;\n        this.crashed = false;\n        this.collision = null;\n        this.gravity = null;\n    }\n    /**\n     * @param {Coordinate} position\n     */\n    move(position) {\n        this.parts.push(position);\n        this.trimParts();\n    }\n    /**\n     * @return {Coordinate}\n     */\n    getHead() {\n        return this.parts[this.parts.length - 1];\n    }\n    hasPartPredict(part) {\n        const treshold = this.crashed ? -1 : 0;\n        return this.getPartIndex(part) > treshold;\n    }\n    trimParts() {\n        while (this.parts.length > this.size) {\n            this.parts.shift();\n        }\n    }\n    hasPart(part) {\n        return -1 !== this.getPartIndex(part);\n    }\n    getPartIndex(part) {\n        const parts = this.parts;\n        for (let i = 0, m = parts.length; i < m; i++) {\n            if (parts[i][0] === part[0] && parts[i][1] === part[1]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    shiftParts(shift) {\n        const x = shift[0] || 0;\n        const y = shift[1] || 0;\n        if (x || y) {\n            for (let i = 0, m = this.parts.length; i < m; i++) {\n                this.parts[i][0] += x;\n                this.parts[i][1] += y;\n            }\n        }\n    }\n    /**\n     * Head-tail switch.\n     */\n    reverse() {\n        let dx;\n        let dy;\n        dx = this.parts[0][0] - this.parts[1][0];\n        dy = this.parts[0][1] - this.parts[1][1];\n        if (dx === 0) {\n            this.direction = dy === -1 ? 1 : 3;\n        }\n        else {\n            this.direction = dx === -1 ? 0 : 2;\n        }\n        this.parts.reverse();\n    }\n}\nexports.Snake = Snake;\n\n\n//# sourceURL=webpack://xssnake/./shared/snake.ts?");

/***/ }),

/***/ "./shared/util.ts":
/*!************************!*\
  !*** ./shared/util.ts ***!
  \************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getRandomName = exports.benchmark = exports.sort = exports.getKey = exports.eq = exports.delta = exports.average = exports.ensureIndexWithinBounds = exports.randomStr = exports.randomArrIndex = exports.randomArrItem = exports.randomRange = exports.extend = exports.clone = void 0;\n/**\n * @param {Object} obj Object to clone.\n * @return {?} Clone of the input object.\n */\nfunction clone(obj) {\n    const res = {};\n    for (const k in obj) {\n        if (obj.hasOwnProperty(k)) {\n            res[k] = obj[k];\n        }\n    }\n    return res;\n}\nexports.clone = clone;\n/**\n * @param {Object} target\n * @param {...Object} varArgs\n */\nfunction extend(target, varArgs) {\n    for (let i = 1; i < arguments.length; i++) {\n        const source = arguments[i];\n        for (const k in source) {\n            if (source.hasOwnProperty(k)) {\n                target[k] = source[k];\n            }\n        }\n    }\n}\nexports.extend = extend;\n// export function filter<Type>(haystack: Type[], needle: Record<string, boolean|string|null>): Type[] {\n//     const filtered = [];\n//     for (let i = 0, m = haystack.length; i < m; i++) {\n//         if (compareProperties(haystack[i], needle)) {\n//             filtered.push(haystack[i]);\n//         }\n//     }\n//     return filtered;\n// }\n//\n// export function compareProperties<Type>(completeObject: Type, subsetObject: Record<string, boolean|string|null>): boolean {\n//     if (completeObject === subsetObject) {\n//         return true;\n//     } else if (subsetObject instanceof Object) {\n//         const keys = Object.keys(subsetObject);\n//         for (let i = 0, l = keys.length; i < l; i++) {\n//             if (!compareProperties(completeObject[keys[i]], subsetObject[keys[i]])) {\n//                 return false;\n//             }\n//         }\n//         return true;\n//     }\n//     return false;\n// }\n/**\n * @param {number} min\n * @param {number} max\n * @return {number}\n */\nfunction randomRange(min, max) {\n    return min + Math.floor(Math.random() * (max - min + 1));\n}\nexports.randomRange = randomRange;\n/**\n * @param {Array} arr\n * @return {?}\n */\nfunction randomArrItem(arr) {\n    return arr[Math.floor(Math.random() * arr.length)];\n}\nexports.randomArrItem = randomArrItem;\n/**\n * @param {Array} arr\n * @return {number}\n */\nfunction randomArrIndex(arr) {\n    return Math.floor(Math.random() * arr.length);\n}\nexports.randomArrIndex = randomArrIndex;\n/**\n * @param {number=} len\n * @return {string}\n */\nfunction randomStr(len = 3) {\n    return Math.random().toString(36).substr(2, len);\n}\nexports.randomStr = randomStr;\n/**\n * Ensure an array index is within bounds.\n * @param {number} index\n * @param {Array} arr\n * @return {number}\n */\nfunction ensureIndexWithinBounds(index, arr) {\n    const len = arr.length;\n    if (index >= len) {\n        return 0;\n    }\n    else if (index < 0) {\n        return len - 1;\n    }\n    return index;\n}\nexports.ensureIndexWithinBounds = ensureIndexWithinBounds;\nfunction average(numbers) {\n    let total = 0;\n    const m = numbers.length;\n    for (let i = 0; i < m; i++) {\n        total += numbers[i];\n    }\n    return m ? total / m : 0;\n}\nexports.average = average;\n/**\n * @param {Coordinate} a\n * @param {Coordinate} b\n * @return {number}\n */\nfunction delta(a, b) {\n    return Math.abs(a[0] - b[0]) + Math.abs(a[1] - b[1]);\n}\nexports.delta = delta;\n/**\n * @param {Coordinate} a\n * @param {Coordinate} b\n * @return {boolean}\n */\nfunction eq(a, b) {\n    return a[0] === b[0] && a[1] === b[1];\n}\nexports.eq = eq;\n/**\n * @param {*} obj\n * @param {*} val\n * @return {?string}\n */\nfunction getKey(obj, val) {\n    for (const k in obj) {\n        if (obj.hasOwnProperty(k) && val === obj[k]) {\n            return k;\n        }\n    }\n    return null;\n}\nexports.getKey = getKey;\n/**\n * Faster sorting function.\n * http://jsperf.com/javascript-sort/\n *\n * @param {Array.<number>} arr\n * @return {Array.<number>}\n */\nfunction sort(arr) {\n    for (let i = 1; i < arr.length; i++) {\n        const tmp = arr[i];\n        let index = i;\n        while (arr[index - 1] > tmp) {\n            arr[index] = arr[index - 1];\n            --index;\n        }\n        arr[index] = tmp;\n    }\n    return arr;\n}\nexports.sort = sort;\n/**\n * @param {number} iterations\n * @param {Function} fn\n * @param {string|number=} label\n */\nfunction benchmark(iterations, fn, label = \"\") {\n    let duration;\n    let i = iterations;\n    const start = +new Date();\n    while (i--) {\n        fn();\n    }\n    duration = +new Date() - start;\n    console.log(label || \"Benchmark\", {\n        x: iterations,\n        avg: duration / iterations,\n        total: duration,\n    });\n}\nexports.benchmark = benchmark;\n/**\n * @return {string}\n */\nfunction getRandomName() {\n    const name = randomArrItem([\n        \"Ant\",\n        \"Bat\",\n        \"Bear\",\n        \"Bird\",\n        \"Cat\",\n        \"Cow\",\n        \"Crab\",\n        \"Croc\",\n        \"Deer\",\n        \"Dodo\",\n        \"Dog\",\n        \"Duck\",\n        \"Emu\",\n        \"Fish\",\n        \"Fly\",\n        \"Fox\",\n        \"Frog\",\n        \"Goat\",\n        \"Hare\",\n        \"Ibis\",\n        \"Kiwi\",\n        \"Lion\",\n        \"Lynx\",\n        \"Miao\",\n        \"Mole\",\n        \"Moth\",\n        \"Mule\",\n        \"Oger\",\n        \"Pig\",\n        \"Pika\",\n        \"Poke\",\n        \"Puma\",\n        \"Puss\",\n        \"Rat\",\n        \"Seal\",\n        \"Swan\",\n        \"Wasp\",\n        \"Wolf\",\n        \"Yak\",\n        \"Zeb\",\n    ]);\n    return name + \".\" + randomRange(10, 99);\n}\nexports.getRandomName = getRandomName;\n\n\n//# sourceURL=webpack://xssnake/./shared/util.ts?");

/***/ }),

/***/ "./shared/util/sanitizer.ts":
/*!**********************************!*\
  !*** ./shared/util/sanitizer.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Sanitizer = void 0;\n/**\n * Sanitizer / Sanitize user input.\n * @param {?=} value\n * @constructor\n */\nclass Sanitizer {\n    constructor(value) {\n        this._value = value;\n        this._valid = true;\n    }\n    /**\n     * @param {string} type\n     * @return {Sanitizer}\n     */\n    assertType(type) {\n        if (typeof this._value !== type) {\n            this._log(\"assertType\", this._value, type);\n            this._valid = false;\n        }\n        return this;\n    }\n    /**\n     * @return {Sanitizer}\n     */\n    assertArray() {\n        if (!(this._value instanceof Array)) {\n            this._log(\"assertArray\", this._value);\n            this._valid = false;\n        }\n        return this;\n    }\n    /**\n     * @return {Sanitizer}\n     */\n    assertJSON() {\n        if (this._valid) {\n            // Don't parse if already invalid\n            try {\n                this._json = JSON.parse(this._value);\n            }\n            catch (err) {\n                this._log(\"assertJSON\", this._value);\n                this._valid = false;\n            }\n        }\n        return this;\n    }\n    /**\n     * @param {Array} arr\n     * @return {Sanitizer}\n     */\n    assertInArray(arr) {\n        if (-1 === arr.indexOf(this._value)) {\n            this._log(\"assertInArray\", this._value, arr);\n            this._valid = false;\n        }\n        return this;\n    }\n    /**\n     * @param {number} min\n     * @param {number} max\n     * @return {Sanitizer}\n     */\n    assertBetween(min, max) {\n        if (typeof this._value !== \"number\") {\n            this._log(\"assertRange type\", this._value);\n            this._valid = false;\n        }\n        else if (this._value < min || this._value > max) {\n            this._log(\"assertRange range\", this._value, min, max);\n            this._valid = false;\n        }\n        return this;\n    }\n    /**\n     *\n     * @return {Sanitizer}\n     */\n    assertIntAsBoolean() {\n        return this.assertBetween(0, 1);\n    }\n    /**\n     * @param {number} min\n     * @param {number=} max\n     * @return {Sanitizer}\n     */\n    assertStringOfLength(min, max) {\n        max = typeof max === \"undefined\" ? min : max;\n        if (typeof this._value !== \"string\") {\n            this._log(\"assertStringOfLength type\", this._value);\n            this._valid = false;\n        }\n        else if (!this._assertLength(min, max)) {\n            this._log(\"assertStringOfLength length\", this._value, min, max);\n            this._valid = false;\n        }\n        return this;\n    }\n    /**\n     * @param {number} min\n     * @param {number} max\n     * @return {Sanitizer}\n     */\n    assertArrayLengthBetween(min, max) {\n        if (!(this._value instanceof Array)) {\n            this._log(\"assertArrayOfLength type\", this._value);\n            this._valid = false;\n        }\n        else if (!this._assertLength(min, max)) {\n            this._log(\"assertArrayOfLength length\", this._value, min, max);\n            this._valid = false;\n        }\n        return this;\n    }\n    _assertLength(min, max) {\n        return this._value.length >= min && this._value.length <= max;\n    }\n    /**\n     * @return {boolean}\n     */\n    valid() {\n        return this._valid;\n    }\n    /**\n     * @param {*=} def\n     * @return {?}\n     */\n    getValueOr(def) {\n        return this._valid ? this._value : def;\n    }\n    /**\n     * @param {*=} def\n     * @return {?}\n     */\n    json(def) {\n        return this._valid ? this._json : def;\n    }\n    /**\n     * @param {string} message\n     * @param {*} value\n     * @param {...*} varArgs\n     * @private\n     */\n    _log(message, value, ...varArgs) {\n        console.warn(\"Validation Error\", message, JSON.stringify(value), varArgs);\n    }\n}\nexports.Sanitizer = Sanitizer;\n\n\n//# sourceURL=webpack://xssnake/./shared/util/sanitizer.ts?");

/***/ }),

/***/ "./node_modules/ws/lib/browser.js":
/*!****************************************!*\
  !*** ./node_modules/ws/lib/browser.js ***!
  \****************************************/
/***/ ((module) => {

eval("\n/**\n * Module dependencies.\n */\n\nvar global = (function() { return this; })();\n\n/**\n * WebSocket constructor.\n */\n\nvar WebSocket = global.WebSocket || global.MozWebSocket;\n\n/**\n * Module exports.\n */\n\nmodule.exports = WebSocket ? ws : null;\n\n/**\n * WebSocket constructor.\n *\n * The third `opts` options object gets ignored in web browsers, since it's\n * non-standard, and throws a TypeError if passed to the constructor.\n * See: https://github.com/einaros/ws/issues/227\n *\n * @param {String} uri\n * @param {Array} protocols (optional)\n * @param {Object) opts (optional)\n * @api public\n */\n\nfunction ws(uri, protocols, opts) {\n  var instance;\n  if (protocols) {\n    instance = new WebSocket(uri, protocols);\n  } else {\n    instance = new WebSocket(uri);\n  }\n  return instance;\n}\n\nif (WebSocket) ws.prototype = WebSocket.prototype;\n\n\n//# sourceURL=webpack://xssnake/./node_modules/ws/lib/browser.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./server/index.ts");
/******/ 	
/******/ })()
;