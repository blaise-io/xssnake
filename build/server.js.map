{"version":3,"sources":["webpack://xssnake/./client/state/state.ts","webpack://xssnake/./server/const.ts","webpack://xssnake/./server/game/serverSnake.ts","webpack://xssnake/./server/netcode/heartbeat.ts","webpack://xssnake/./server/netcode/server.ts","webpack://xssnake/./server/room/matcher.ts","webpack://xssnake/./server/room/roomManager.ts","webpack://xssnake/./server/room/serverOptions.ts","webpack://xssnake/./server/room/serverPlayer.ts","webpack://xssnake/./server/room/serverPlayerRegistry.ts","webpack://xssnake/./server/room/serverRoom.ts","webpack://xssnake/./server/room/serverRoundSet.ts","webpack://xssnake/./shared/config.ts","webpack://xssnake/./shared/const.ts","webpack://xssnake/./shared/game/collision.ts","webpack://xssnake/./shared/game/snakeMove.ts","webpack://xssnake/./shared/room/options.ts","webpack://xssnake/./shared/room/player.ts","webpack://xssnake/./shared/room/playerRegistry.ts","webpack://xssnake/./shared/snake.ts","webpack://xssnake/./shared/util.ts","webpack://xssnake/./shared/util/sanitizer.ts","webpack://xssnake/./node_modules/ws/browser.js","webpack://xssnake/external \"events\"","webpack://xssnake/webpack/bootstrap","webpack://xssnake/webpack/runtime/compat get default export","webpack://xssnake/webpack/runtime/define property getters","webpack://xssnake/webpack/runtime/hasOwnProperty shorthand","webpack://xssnake/webpack/runtime/make namespace object","webpack://xssnake/./server/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;AAAO;AACP;AACA;;;;;;;;;;;;;;;;;;ACFO;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACH6C;AACI;AACb;AACpC,0BAA0B,gDAAK;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,6DAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yDAAc;AACpC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACvCA;AACA,WAAW,kBAAkB;AAC7B;AACA;AAC6E;AACrB;AACjD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,kDAAO,EAAE,kDAAO;AAChE;AACA;AACA;AACA;AACA,wCAAwC,gEAAqB;AAC7D;AACA;AACA,+BAA+B,kDAAO;AACtC,+BAA+B,kDAAO;AACtC;AACA;AACA;AACA,yBAAyB,kDAAO;AAChC;AACA;AACA,gCAAgC,gEAA4B;AAC5D;AACA;;;;;;;;;;;;;;;;;;;;;;AChCsC;AACS;AAC6B;AACpB;AACJ;AAC7C;AACP;AACA,2BAA2B,gDAAY;AACvC,+BAA+B,gEAAiB;AAChD,sBAAsB,sCAAe;AACrC,kBAAkB,uDAAW;AAC7B,kBAAkB,uDAAW;AAC7B,kBAAkB,uDAAW;AAC7B,SAAS;AACT;AACA,gBAAgB,4DAAY;AAC5B,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACtBA;AACA,WAAW,wBAAwB;AACnC;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC9BA;AACA,WAAW,eAAe;AAC1B;AACA;AACoS;AACtP;AACU;AACpB;AACY;AACN;AACnC;AACP;AACA;AACA,mBAAmB,wBAAwB;AAC3C;AACA,2BAA2B,6CAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yDAAc;AAC1B,YAAY,2DAAgB;AAC5B,YAAY,gEAAqB;AACjC;AACA;AACA;AACA;AACA,mBAAmB,yDAAc;AACjC,mBAAmB,2DAAgB;AACnC,mBAAmB,gEAAqB;AACxC;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC,gBAAgB;AAChB;AACA;AACA;AACA,mBAAmB,uDAAS,CAAC,0DAAe;AAC5C,mBAAmB,mDAAU;AAC7B;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wDAAa;AACpC;AACA;AACA,wBAAwB,6DAAkB;AAC1C;AACA;AACA;AACA,wBAAwB,6DAAkB;AAC1C;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,6DAAS;AACnC,sBAAsB,yDAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,6DAAS;AAC1C,0CAA0C,0DAAe;AACzD;AACA;AACA;AACA;AACA,mBAAmB,2DAAgB;AACnC;AACA;AACA;AACA,mBAAmB,yDAAc;AACjC;AACA;AACA,mBAAmB,oDAAS;AAC5B;AACA;AACA,mBAAmB,2DAAgB;AACnC;AACA,eAAe,wDAAa;AAC5B;AACA;AACA;AACA;AACA,uBAAuB,wDAAa;AACpC;AACA,wBAAwB,4DAAiB;AACzC,wBAAwB,+DAAoB;AAC5C,wBAAwB,+DAAoB;AAC5C;AACA;AACA,wBAAwB,6DAAkB;AAC1C;AACA;AACA;;;;;;;;;;;;;;;;;ACnJA;AACA,WAAW,OAAO;AAClB;AACA,aAAa;AACb;AAC0D;AACN;AAC7C,4BAA4B,yDAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,6BAA6B;AACrF;AACA,eAAe,kBAAkB;AACjC;AACA;AACA,oBAAoB,+DAAoB;AACxC;AACA;AACA,eAAe,mBAAmB;AAClC,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACnCwI;AACtF;AACZ;AACY;AACM;AACN;AACK;AAChD,2BAA2B,uDAAM;AACxC;AACA;AACA;AACA;AACA,2BAA2B,gDAAY;AACvC;AACA;AACA;AACA;AACA;AACA,6BAA6B,+DAAe;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,8DAAmB;AACtD;AACA,yBAAyB,+DAAoB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yDAAc;AACtC;AACA;AACA,wCAAwC,yDAAc;AACtD;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,wBAAwB,6DAAS;AACjC,kCAAkC,gEAAqB;AACvD,wBAAwB,2DAAa;AACrC;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,6BAA6B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B;AACA;AACA,yBAAyB,0DAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,iCAAiC,0DAAe;AAChD;AACA;AACA;;;;;;;;;;;;;;;;;ACpJ0D;AACQ;AAC3D,mCAAmC,uEAAc;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,OAAO;AACvD,iCAAiC,+DAAoB;AACrD;AACA;AACA;AACA,uBAAuB,yBAAyB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,MAAM;AACrB;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC3D8F;AACtC;AAClB;AACwB;AACZ;AAC3C;AACP;AACA;AACA;AACA;AACA,2BAA2B,gDAAY;AACvC,2BAA2B,uEAAoB;AAC/C,0BAA0B,2DAAc;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0DAAe;AACvC,wBAAwB,+DAAoB;AAC5C;AACA;AACA,8BAA8B,6DAAS;AACvC;AACA;AACA;AACA,6BAA6B,0DAAe;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4DAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,kBAAkB;AACpD;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC5FA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,0BAA0B;AACrC,WAAW,aAAa;AACxB;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACzEO;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACHA;AACA;AACA;AACP;AACO;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACP;AACO;AACA;AACA;AACA;AACP;AACA;AACA;AACA;AACA;AACO;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACxFP;AACA,WAAW,WAAW;AACtB,WAAW,OAAO;AAClB;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACdqF;AAC7C;AACjC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iDAAS,OAAO,8CAAU;AACrD;AACA;AACA;AACA,uBAAuB,iDAAS,OAAO,8CAAU;AACjD;AACA;AACA,uBAAuB,iDAAS,OAAO,qDAAiB;AACxD;AACA,2CAA2C,OAAO;AAClD;AACA;AACA;AACA;AACA,2BAA2B,iDAAS,OAAO,kDAAc;AACzD;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACtDiD;AACR;AACK;AACvC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,sDAAS;AACvC,8BAA8B,iDAAa;AAC3C,wBAAwB,iDAAa;AACrC,4BAA4B,sDAAS;AACrC,8BAA8B,wFAAuC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACnCO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACpBO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC7BO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,OAAO;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzEA;AACA,WAAW,OAAO;AAClB,YAAY,EAAE;AACd;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB;AACO;AACP,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,OAAO;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,2CAA2C,OAAO;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA,WAAW,MAAM;AACjB,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA,WAAW,MAAM;AACjB,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,WAAW;AACtB,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,WAAW;AACtB,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,YAAY;AACZ;AACO;AACP,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,WAAW,eAAe;AAC1B;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC1NA;AACA;AACA,WAAW,GAAG;AACd;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,EAAE;AACjB,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACtIa;;AAEb;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACPA,oC;;;;;;UCAA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA;WACA,gCAAgC,YAAY;WAC5C;WACA,E;;;;;WCPA;WACA;WACA;WACA;WACA,wCAAwC,yCAAyC;WACjF;WACA;WACA,E;;;;;WCPA,wF;;;;;WCAA;WACA;WACA;WACA,sDAAsD,kBAAkB;WACxE;WACA,+CAA+C,cAAc;WAC7D,E;;;;;;;;;;;;ACN0C;AAC1C,IAAI,mDAAM","file":"server.js","sourcesContent":["export class State {\n}\nState.keysBlocked = false;\n","export const GAME_LEFT = 0;\nexport const GAME_TOP = 0;\nexport const SERVER_TICK_INTERVAL = 1000 / 20;\nexport const SERVER_MAX_TOLERATED_LATENCY = 150;\n","import { GAME_SHIFT_MAP } from \"../../shared/const\";\nimport { SnakeMove } from \"../../shared/game/snakeMove\";\nimport { Snake } from \"../../shared/snake\";\nexport class ServerSnake extends Snake {\n    constructor(index, level) {\n        super(index, level);\n        this.index = index;\n        this.level = level;\n        this.elapsed = 0;\n    }\n    destruct() {\n        this.level = null;\n    }\n    serialize() {\n        return [this.index, this.direction, this.parts];\n    }\n    handleNextMove(tick, elapsed, shift, players) {\n        this.elapsed += elapsed;\n        if (!this.crashed && this.elapsed >= this.speed) {\n            const move = new SnakeMove(this, players, this.level, this.getNextPosition());\n            this.elapsed -= this.speed;\n            if (!move.collision) {\n                this.collision = null;\n                this.move(move.location);\n            }\n            else if (!this.collision) {\n                this.collision = move.collision;\n                this.collision.tick = tick;\n            }\n        }\n    }\n    getNextPosition() {\n        const head = this.getHead();\n        const shift = GAME_SHIFT_MAP[this.direction];\n        return [head[0] + shift[0], head[1] + shift[1]];\n    }\n    hasCollisionLteTick(tick) {\n        return !this.crashed && this.collision && this.collision.tick <= tick;\n    }\n}\n","/**\n * @param {room.ServerPlayer} player\n * @constructor\n */\nimport { HEARTBEAT_INTERVAL_MS, NC_PING, NC_PONG } from \"../../shared/const\";\nimport { SERVER_MAX_TOLERATED_LATENCY } from \"../const\";\nexport class ServerHeartbeat {\n    constructor(player) {\n        this.player = player;\n        this.latency = 0;\n        this.pingSent = 0;\n        this.bindEvents();\n    }\n    destruct() {\n        this.player.emitter.removeAllListeners([NC_PING, NC_PONG]);\n        this.player = null;\n    }\n    isAlive() {\n        const pingSent = this.pingSent || +new Date();\n        return +new Date() - pingSent < HEARTBEAT_INTERVAL_MS * 2;\n    }\n    bindEvents() {\n        this.player.emitter.on(NC_PING, this.ping.bind(this));\n        this.player.emitter.on(NC_PONG, this.pong.bind(this));\n    }\n    ping() {\n        this.pingSent = +new Date();\n        this.player.emit(NC_PONG);\n    }\n    pong() {\n        this.latency = Math.min(SERVER_MAX_TOLERATED_LATENCY, (+new Date() - this.pingSent) / 2);\n    }\n}\n","import { EventEmitter } from \"events\";\nimport { Server as WebsocketServer } from \"ws\";\nimport { SERVER_HOST, SERVER_PATH, SERVER_PORT } from \"../../shared/config\";\nimport { ServerRoomManager } from \"../room/roomManager\";\nimport { ServerPlayer } from \"../room/serverPlayer\";\nexport class Server {\n    constructor() {\n        this.emitter = new EventEmitter();\n        this.roomManager = new ServerRoomManager(this);\n        this.ws = new WebsocketServer({\n            host: SERVER_HOST,\n            port: SERVER_PORT,\n            path: SERVER_PATH,\n        });\n        this.ws.on(\"connection\", () => {\n            new ServerPlayer(this, this.ws);\n        });\n    }\n    destruct() {\n        this.roomManager.destruct();\n        this.ws.close();\n    }\n}\n","/**\n * @param {Array.<room.ServerRoom>} rooms\n * @constructor\n */\nexport class Matcher {\n    constructor(rooms) {\n        this.rooms = rooms;\n    }\n    destruct() {\n        this.rooms = null;\n    }\n    /**\n     * @param {room.ServerOptions} requestOptions\n     * @return {room.ServerRoom}\n     */\n    getRoomMatching(requestOptions) {\n        const rooms = this.rooms;\n        if (!requestOptions.isPrivate) {\n            // Shortcut.\n            for (let i = 0, m = rooms.length; i < m; i++) {\n                const room = rooms[i];\n                if (room.isAwaitingPlayers()) {\n                    if (room.options.matches(requestOptions)) {\n                        return room;\n                    }\n                }\n            }\n        }\n        return null;\n    }\n}\n","/**\n * @param {netcode.Server} server\n * @constructor\n */\nimport { NC_OPTIONS_SERIALIZE, NC_PLAYERS_SERIALIZE, NC_ROOM_JOIN_ERROR, NC_ROOM_JOIN_KEY, NC_ROOM_JOIN_MATCHING, NC_ROOM_SERIALIZE, NC_ROOM_STATUS, NC_ROUND_SERIALIZE, ROOM_FULL, ROOM_IN_PROGRESS, ROOM_INVALID_KEY, ROOM_JOINABLE, ROOM_KEY_LENGTH, ROOM_NOT_FOUND, } from \"../../shared/const\";\nimport { randomStr } from \"../../shared/util\";\nimport { Sanitizer } from \"../../shared/util/sanitizer\";\nimport { Matcher } from \"./matcher\";\nimport { ServerOptions } from \"./serverOptions\";\nimport { ServerRoom } from \"./serverRoom\";\nexport class ServerRoomManager {\n    constructor(server) {\n        this.server = server;\n        /** @type {Array.<room.ServerRoom>} */\n        this.rooms = [];\n        this.matcher = new Matcher(this.rooms);\n        this.bindEvents();\n    }\n    destruct() {\n        this.removeAllRooms();\n        this.matcher.destruct();\n        this.server.emitter.removeAllListeners([\n            NC_ROOM_STATUS,\n            NC_ROOM_JOIN_KEY,\n            NC_ROOM_JOIN_MATCHING,\n        ]);\n    }\n    bindEvents() {\n        const emitter = this.server.emitter;\n        emitter.on(NC_ROOM_STATUS, this.emitRoomStatus.bind(this));\n        emitter.on(NC_ROOM_JOIN_KEY, this.autojoinRoom.bind(this));\n        emitter.on(NC_ROOM_JOIN_MATCHING, this.joinMatchingRoom.bind(this));\n    }\n    /**\n     * @param {string} key\n     * @return {room.ServerRoom}\n     */\n    room(key) {\n        return this.rooms[key];\n    }\n    /**\n     * @param {room.ServerRoom} room\n     */\n    remove(room) {\n        room.destruct();\n        for (let i = 0, m = this.rooms.length; i < m; i++) {\n            if (room === this.rooms[i]) {\n                this.rooms.splice(i, 1);\n            }\n        }\n    }\n    removeAllRooms() {\n        for (let i = 0, m = this.rooms.length; i < m; i++) {\n            this.rooms[i].destruct();\n        }\n        this.rooms.length = 0;\n    }\n    /**\n     * @param {room.ServerOptions} preferences\n     * @return {room.ServerRoom}\n     */\n    createRoom(preferences) {\n        let room;\n        const id = randomStr(ROOM_KEY_LENGTH);\n        room = new ServerRoom(this.server, preferences, id);\n        this.rooms.push(room);\n        return room;\n    }\n    /**\n     * @param {Array.<?>} dirtyKeyArr\n     * @param {room.ServerPlayer} player\n     */\n    autojoinRoom(dirtyKeyArr, player) {\n        let room;\n        let key;\n        let status;\n        key = this.getSanitizedRoomKey(dirtyKeyArr);\n        status = this.getRoomStatus(key);\n        if (status === ROOM_JOINABLE) {\n            room = this.getRoomByKey(key);\n            room.addPlayer(player);\n            player.emit(NC_ROUND_SERIALIZE, room.rounds.round.serialize());\n            room.detectAutostart();\n        }\n        else {\n            player.emit(NC_ROOM_JOIN_ERROR, [status]);\n        }\n    }\n    /**\n     * @param {Array.<?>} dirtySerializeOptions\n     * @param {room.ServerPlayer} player\n     * @private\n     */\n    joinMatchingRoom(dirtySerializeOptions, player) {\n        let options;\n        let room;\n        let emitDataArr;\n        emitDataArr = new Sanitizer(dirtySerializeOptions).assertArray().getValueOr([]);\n        options = new ServerOptions(emitDataArr);\n        room = this.matcher.getRoomMatching(options);\n        room = room || this.createRoom(options);\n        room.addPlayer(player);\n        room.emitAll(player);\n        room.detectAutostart();\n    }\n    getRoomByKey(key) {\n        for (let i = 0, m = this.rooms.length; i < m; i++) {\n            if (key === this.rooms[i].key) {\n                return this.rooms[i];\n            }\n        }\n        return null;\n    }\n    getSanitizedRoomKey(dirtyKeyArr) {\n        const keySanitizer = new Sanitizer(dirtyKeyArr[0]);\n        keySanitizer.assertStringOfLength(ROOM_KEY_LENGTH);\n        return keySanitizer.getValueOr();\n    }\n    getRoomStatus(key) {\n        if (!key) {\n            return ROOM_INVALID_KEY;\n        }\n        const room = this.getRoomByKey(key);\n        if (!room) {\n            return ROOM_NOT_FOUND;\n        }\n        else if (room.isFull()) {\n            return ROOM_FULL;\n        }\n        else if (room.rounds.hasStarted()) {\n            return ROOM_IN_PROGRESS;\n        }\n        return ROOM_JOINABLE;\n    }\n    emitRoomStatus(dirtyKeyArr, player) {\n        const key = this.getSanitizedRoomKey(dirtyKeyArr);\n        const status = this.getRoomStatus(key);\n        if (status === ROOM_JOINABLE) {\n            const room = this.getRoomByKey(key);\n            player.emit(NC_ROOM_SERIALIZE, room.serialize());\n            player.emit(NC_OPTIONS_SERIALIZE, room.options.serialize());\n            player.emit(NC_PLAYERS_SERIALIZE, room.players.serialize());\n        }\n        else {\n            player.emit(NC_ROOM_JOIN_ERROR, [status]);\n        }\n    }\n}\n","/**\n * @param {Array=} dirtyOptions\n * @constructor\n * @extends {room.Options}\n */\nimport { NC_OPTIONS_SERIALIZE } from \"../../shared/const\";\nimport { Options } from \"../../shared/room/options\";\nexport class ServerOptions extends Options {\n    constructor(dirtyOptions) {\n        super();\n        if (dirtyOptions) {\n            this.deserialize(dirtyOptions);\n        }\n    }\n    // extend(room.ServerOptions.prototype, room.Options.prototype);\n    // extend(room.ServerOptions.prototype, /** @lends {room.ServerOptions.prototype} */ {\n    /**\n     * @param {room.ServerPlayer} player\n     */\n    emit(player) {\n        player.emit(NC_OPTIONS_SERIALIZE, this.serialize());\n    }\n    /**\n     * @param {room.ServerOptions} request\n     * @return {boolean}\n     */\n    matches(request) {\n        return (!this.isPrivate &&\n            !request.isPrivate &&\n            request.isXSS === this.isXSS &&\n            (request.isQuickGame ||\n                (request.levelset === this.levelset &&\n                    request.hasPowerups === this.hasPowerups &&\n                    request.maxPlayers <= this.maxPlayers)));\n    }\n}\n","import { NC_PLAYER_NAME, NETCODE_SYNC_MS, PLAYER_NAME_MINLENGTH, SE_PLAYER_COLLISION, SE_PLAYER_DISCONNECT, } from \"../../shared/const\";\nimport { Player } from \"../../shared/room/player\";\nimport { EventEmitter } from \"events\";\nimport { getRandomName } from \"../../shared/util\";\nimport { Sanitizer } from \"../../shared/util/sanitizer\";\nimport { ServerSnake } from \"../game/serverSnake\";\nimport { ServerHeartbeat } from \"../netcode/heartbeat\";\nexport class ServerPlayer extends Player {\n    constructor(server, connection) {\n        super();\n        this.server = server;\n        this.connection = connection;\n        this.emitter = new EventEmitter();\n        this.room = null;\n        this.connection.on(\"message\", this.onmessage.bind(this));\n        this.connection.on(\"close\", this.onclose.bind(this));\n        this.connected = true;\n        this.bindEvents();\n        this.heartbeat = new ServerHeartbeat(this);\n    }\n    destruct() {\n        if (this.connected) {\n            this.disconnect();\n        }\n        this.unbindEvents();\n        this.heartbeat.destruct(); // Awww.\n        this.server = null;\n        this.snake = null;\n        this.room = null;\n        this.heartbeat = null;\n    }\n    disconnect() {\n        this.connected = false;\n        if (this.snake) {\n            this.snake.crashed = true;\n            this.room.emitter.emit(SE_PLAYER_COLLISION, [this]);\n        }\n        this.emitMessage(SE_PLAYER_DISCONNECT, this);\n        if (this.connection) {\n            this.connection.close();\n            this.connection = null;\n        }\n        this.emitter.removeAllListeners();\n    }\n    /**\n     * @param {string} jsonStr\n     */\n    onmessage(jsonStr) {\n        const message = new netcode.Message(jsonStr);\n        console.log(\"IN \", this.name, jsonStr);\n        if (message.isClean) {\n            this.emitMessage(message.event, message.data);\n        }\n    }\n    emitMessage(event, data) {\n        let playerEmits, roomEmits;\n        playerEmits = this.emitter.emit(event, data);\n        roomEmits = this.room && this.room.emitter.emit(event, data, this);\n        // Global events (connecting, finding room).\n        if (!playerEmits && !roomEmits) {\n            this.server.emitter.emit(event, data, this);\n        }\n    }\n    onclose() {\n        if (this.room && this.room.rounds && this.room.rounds.hasStarted()) {\n            // Cannot destruct immediately, game expects player.\n            // Room should destruct player at end of round, or\n            // when all players in room have disconnected.\n            this.disconnect();\n        }\n        else {\n            this.destruct();\n        }\n    }\n    bindEvents() {\n        this.emitter.on(NC_PLAYER_NAME, this.setName.bind(this));\n    }\n    unbindEvents() {\n        this.emitter.removeAllListeners(NC_PLAYER_NAME);\n    }\n    /**\n     * @param {?} dirtyNameArr\n     * @return {string}\n     */\n    setName(dirtyNameArr) {\n        this.name = new Sanitizer(dirtyNameArr[0])\n            .assertStringOfLength(PLAYER_NAME_MINLENGTH, 20)\n            .getValueOr(getRandomName());\n        return this.name;\n    }\n    /**\n     * Send data to client\n     * @param {number} event\n     * @param {Array.<string|number|Array>=} data\n     */\n    emit(event, data) {\n        let emit;\n        if (!this.connected) {\n            return false;\n        }\n        else if (!this.heartbeat.isAlive()) {\n            this.disconnect();\n            return false;\n        }\n        else if (this.connection) {\n            if (data) {\n                emit = data.slice();\n                emit.unshift(event);\n            }\n            else {\n                emit = [event];\n            }\n            console.log(\"OUT\", this.name, JSON.stringify(emit));\n            this.connection.send(JSON.stringify(emit), function (error) {\n                if (error) {\n                    console.error(\"Error sending message\", error);\n                }\n            }.bind(this));\n        }\n    }\n    /**\n     * @param {string} type\n     * @param {*=} data\n     */\n    broadcast(type, data) {\n        if (this.room) {\n            this.room.players.emit(type, data, this);\n        }\n    }\n    /**\n     * @param {number} index\n     * @param {level.Level} level\n     */\n    setSnake(index, level) {\n        this.snake = new ServerSnake(index, level);\n    }\n    unsetSnake() {\n        if (this.snake) {\n            this.snake.destruct();\n        }\n    }\n    /**\n     * @return {number}\n     */\n    getMaxMismatchesAllowed() {\n        const latency = Math.min(NETCODE_SYNC_MS, this.heartbeat.latency);\n        return Math.ceil(latency / this.snake.speed);\n    }\n}\n","import { NC_PLAYERS_SERIALIZE } from \"../../shared/const\";\nimport { PlayerRegistry } from \"../../shared/room/playerRegistry\";\nexport class ServerPlayerRegistry extends PlayerRegistry {\n    constructor() {\n        super();\n        this.averageLatencyInTicks = 0;\n    }\n    /**\n     * Send data to everyone in the room.\n     */\n    emit(type, data, exclude) {\n        for (let i = 0, m = this.players.length; i < m; i++) {\n            if (exclude !== this.players[i]) {\n                this.players[i].emit(type, data);\n            }\n        }\n    }\n    /**\n     * Players get their own message because serialize contains local flag.\n     */\n    emitPlayers() {\n        for (let i = 0, m = this.players.length; i < m; i++) {\n            this.players[i].emit(NC_PLAYERS_SERIALIZE, this.serialize(this.players[i]));\n        }\n    }\n    removeDisconnectedPlayers() {\n        for (let i = 0; i < this.players.length; i++) {\n            if (!this.players[i].connected) {\n                this.players[i].destruct();\n                this.remove(this.players[i]);\n                this.emitPlayers();\n            }\n        }\n    }\n    setSnakes(level) {\n        for (let i = 0, m = this.players.length; i < m; i++) {\n            this.players[i].setSnake(i, level);\n        }\n    }\n    getCollisionsOnTick(tick) {\n        const crashingPlayers = [];\n        for (let i = 0, m = this.players.length; i < m; i++) {\n            if (this.players[i].snake.hasCollisionLteTick(tick)) {\n                crashingPlayers.push(this.players[i]);\n            }\n        }\n        return crashingPlayers;\n    }\n    /**\n     * @param {number} tick\n     * @param {number} elapsed\n     * @param {Shift} shift\n     */\n    moveSnakes(tick, elapsed, shift) {\n        for (let i = 0, m = this.players.length; i < m; i++) {\n            this.players[i].snake.handleNextMove(tick, elapsed, shift, this.players);\n            this.players[i].snake.shiftParts(shift);\n        }\n    }\n}\n","import { NC_CHAT_MESSAGE, NC_ROOM_SERIALIZE, SE_PLAYER_DISCONNECT } from \"../../shared/const\";\nimport { Sanitizer } from \"../../shared/util/sanitizer\";\nimport { EventEmitter } from \"events\";\nimport { ServerPlayerRegistry } from \"./serverPlayerRegistry\";\nimport { ServerRoundSet } from \"./serverRoundSet\";\nexport class ServerRoom {\n    constructor(server, options, key) {\n        this.server = server;\n        this.options = options;\n        this.key = key;\n        this.emitter = new EventEmitter();\n        this.players = new ServerPlayerRegistry();\n        this.rounds = new ServerRoundSet(this.emitter, this.players, this.options);\n        this.bindEvents();\n    }\n    destruct() {\n        this.emitter.removeAllListeners();\n        this.players.destruct();\n        this.rounds.destruct();\n        this.server = null;\n        this.players = null;\n        this.rounds = null;\n    }\n    bindEvents() {\n        this.emitter.on(NC_CHAT_MESSAGE, this.ncChatMessage.bind(this));\n        this.emitter.on(SE_PLAYER_DISCONNECT, this.handlePlayerDisconnect.bind(this));\n    }\n    ncChatMessage(serializedMessage, player) {\n        const sanitizer = new Sanitizer(serializedMessage[0]);\n        sanitizer.assertStringOfLength(1, 64);\n        if (sanitizer.valid()) {\n            // TODO Prevent spam.\n            player.broadcast(NC_CHAT_MESSAGE, [\n                this.players.players.indexOf(player),\n                sanitizer.getValueOr(),\n            ]);\n        }\n    }\n    restartRounds() {\n        //        this.rounds.destruct();\n        //        this.rounds = new RoundManager(this);\n        //        this.rounds.detectAutoStart();\n        //        this.emitState();\n    }\n    isAwaitingPlayers() {\n        return !this.isFull() && !this.rounds.hasStarted();\n    }\n    /**\n     * @return {Array.<string>}\n     */\n    serialize() {\n        return [this.key];\n    }\n    /**\n     * @param {room.ServerPlayer} player\n     */\n    addPlayer(player) {\n        this.players.add(player);\n        player.room = this;\n        this.players.emitPlayers();\n    }\n    detectAutostart() {\n        this.rounds.detectAutostart(this.isFull());\n    }\n    emit(player) {\n        player.emit(NC_ROOM_SERIALIZE, this.serialize());\n    }\n    emitAll(player) {\n        this.emit(player);\n        this.options.emit(player);\n        this.rounds.round.emit(player);\n    }\n    handlePlayerDisconnect(player) {\n        // Remove immediately if rounds have not started.\n        // [else: set player.connected to false]\n        if (!this.rounds.hasStarted()) {\n            this.players.remove(player);\n        }\n        this.players.emitPlayers();\n        this.detectEmptyRoom();\n    }\n    detectEmptyRoom() {\n        if (!this.players.filter({ connected: true }).length) {\n            this.server.roomManager.remove(this);\n        }\n    }\n    /**\n     * @return {boolean}\n     */\n    isFull() {\n        return this.players.getTotal() === this.options.maxPlayers;\n    }\n}\n","/**\n * A set of rounds.\n * After N rounds, the player with most points wins.\n *\n * @param {EventEmitter} roomEmitter\n * @param {room.ServerPlayerRegistry} players\n * @param {room.Options} options\n * @constructor\n */\nexport class ServerRoundSet {\n    constructor(ServerRoundSet) {\n        this.roomEmitter = roomEmitter;\n        this.players = players;\n        this.options = options;\n        this.levelPlayset = new LevelPlayset(options.levelset);\n        this.round = new ServerRound(roomEmitter, players, options, this.levelPlayset);\n        this.score = new ServerScore(players);\n        this.roundIndex = 0;\n        this.bindEvents();\n    }\n    destruct() {\n        this.roomEmitter.removeAllListeners(SE_PLAYER_COLLISION);\n        clearTimeout(this.nextRoundTimeout);\n        this.levelPlayset.destruct();\n        this.levelPlayset = null;\n        this.round.destruct();\n        this.round = null;\n        this.score.destruct();\n        this.score = null;\n        this.players = null;\n        this.options = null;\n    }\n    bindEvents() {\n        this.roomEmitter.on(SE_PLAYER_COLLISION, this.handleCollisions.bind(this));\n    }\n    /**\n     * @param {room.ServerPlayer} winner\n     */\n    switchRounds(winner) {\n        const delay = winner ? SECONDS_ROUND_GLOAT : SECONDS_ROUND_PAUSE;\n        if (this.hasSetWinner()) {\n            // TODO\n        }\n        else if (!this.round.wrappingUp) {\n            this.round.wrapUp(winner);\n            this.nextRoundTimeout = setTimeout(this.startNewRound.bind(this), delay * 1000);\n        }\n    }\n    startNewRound() {\n        this.round.destruct();\n        this.round = new ServerRound(this.roomEmitter, this.players, this.options, this.levelPlayset);\n        this.round.emitAll();\n        this.players.removeDisconnectedPlayers();\n        this.round.toggleCountdown(true);\n    }\n    hasSetWinner() {\n        return false;\n    }\n    handleCollisions(crashingPlayers) {\n        const alive = this.round.getAlivePlayers();\n        this.score.update(crashingPlayers, this.round.level);\n        if (alive.length <= 1) {\n            this.switchRounds(alive[0] || null);\n        }\n    }\n    hasStarted() {\n        return this.roundIndex >= 1 || this.round.started;\n    }\n    detectAutostart(full) {\n        if (full && 0 === this.roundIndex) {\n            this.round.toggleCountdown(true);\n        }\n    }\n}\n","export const SERVER_HOST = \"127.0.0.1\";\nexport const SERVER_PORT = 8001;\nexport const SERVER_PATH = \"\";\nexport const SERVER_ENDPOINT = SERVER_HOST + \":\" + SERVER_PORT + SERVER_PATH;\n","export const WIDTH = 256;\nexport const HEIGHT = 161;\nexport const GAME_TILE = 4;\n// TODO: enums\nexport const NC_CHAT_NOTICE = 10;\nexport const NC_CHAT_MESSAGE = 11;\nexport const NC_GAME_DESPAWN = 20;\nexport const NC_GAME_STATE = 21;\nexport const NC_GAME_SPAWN = 22;\nexport const NC_PING = 0;\nexport const NC_PONG = 1;\nexport const NC_PLAYER_NAME = 30;\nexport const NC_PLAYERS_SERIALIZE = 31;\nexport const NC_ROOM_JOIN_KEY = 40;\nexport const NC_ROOM_JOIN_MATCHING = 41;\nexport const NC_ROOM_SERIALIZE = 42;\nexport const NC_ROOM_START = 43;\nexport const NC_ROOM_STATUS = 44;\nexport const NC_ROOM_JOIN_ERROR = 45;\nexport const NC_OPTIONS_SERIALIZE = 47;\nexport const NC_ROUND_SERIALIZE = 50;\nexport const NC_ROUND_COUNTDOWN = 51;\nexport const NC_ROUND_START = 52;\nexport const NC_ROUND_WRAPUP = 53;\nexport const NC_SCORE_UPDATE = 60;\nexport const NC_SNAKE_ACTION = 70;\nexport const NC_SNAKE_CRASH = 71;\nexport const NC_SNAKE_SIZE = 72;\nexport const NC_SNAKE_SPEED = 73;\nexport const NC_SNAKE_UPDATE = 74;\nexport const NC_XSS = 666;\n// Server EventEmitters\nexport const SE_PLAYER_DISCONNECT = 101;\nexport const SE_PLAYER_COLLISION = 102;\nexport const HEARTBEAT_INTERVAL_MS = 5000;\nexport const GAME_SHIFT_MAP = [\n    [-1, 0],\n    [0, -1],\n    [1, 0],\n    [0, 1],\n];\nexport const DIRECTION_LEFT = 0;\nexport const DIRECTION_UP = 1;\nexport const DIRECTION_RIGHT = 2;\nexport const DIRECTION_DOWN = 3;\nexport const ROOM_KEY_LENGTH = 5;\nexport const ROOM_CAPACITY = 6;\nexport const ROUNDS_MAX = 3;\nexport const ROOM_WIN_BY_MIN = 2;\nexport const PLAYER_NAME_MINLENGTH = 1;\nexport const PLAYER_NAME_MAXWIDTH = 36;\nexport const SECONDS_ROUND_PAUSE = 3;\nexport const SECONDS_ROUND_GLOAT = 5;\nexport const SECONDS_ROUNDSET_GLOAT = 10;\nexport const SECONDS_ROUND_COUNTDOWN = 3;\nexport const SPAWN_SOMETHING_EVERY = [20, 60];\nexport const SPAWN_CHANCE_APPLE = 0.9;\nexport const SNAKE_SPEED = 120;\nexport const SNAKE_SIZE = 4;\nexport const FIELD_VALUE_EASY = 1;\nexport const FIELD_VALUE_MEDIUM = 2;\nexport const FIELD_VALUE_HARD = 3;\nexport const ROOM_JOINABLE = 1;\nexport const ROOM_INVALID_KEY = 2;\nexport const ROOM_FULL = 3;\nexport const ROOM_NOT_FOUND = 4;\nexport const ROOM_IN_PROGRESS = 5;\nexport const ROOM_UNKNOWN_ERROR = 6;\nexport const CRASH_UNKNOWN = 0;\nexport const CRASH_WALL = 1;\nexport const CRASH_MOVING_WALL = 2;\nexport const CRASH_SELF = 3;\nexport const CRASH_OPPONENT = 4;\nexport const CRASH_OPPONENT_DRAW = 5;\nexport const NETCODE_PING_INTERVAL = 3000;\nexport const NETCODE_SYNC_MS = 500;\nexport const VALIDATE_SUCCES = 0;\nexport const VALIDATE_ERR_GAP = 1;\nexport const VALIDATE_ERR_NO_COMMON = 2;\nexport const VALIDATE_ERR_MISMATCHES = 3;\nexport const SCORE_LEADING = 1;\nexport const SCORE_NEUTRAL = 2;\nexport const SCORE_BEHIND = 3;\nexport const SPAWN_APPLE = 1;\nexport const SPAWN_POWERUP = 2;\nexport const NOTICE_CRASH = 1;\nexport const NOTICE_JOIN = 2;\nexport const NOTICE_DISCONNECT = 3;\nexport const NOTICE_NEW_ROUND = 4;\n","/**\n * @param {Coordinate} part\n * @param {number} into\n * @constructor\n */\nexport class Collision {\n    constructor(location, into) {\n        this.location = location;\n        this.into = into;\n        this.tick = 0;\n    }\n    serialize() {\n        return this.location;\n    }\n}\n","import { CRASH_MOVING_WALL, CRASH_OPPONENT, CRASH_SELF, CRASH_WALL } from \"../const\";\nimport { Collision } from \"./collision\";\nexport class SnakeMove {\n    constructor(snake, players, level, location) {\n        this.snake = snake;\n        this.players = players;\n        this.level = level;\n        this.location = location;\n        this.collision = this.getCollission();\n    }\n    getParts(part) {\n        const parts = this.snake.parts.slice();\n        parts.unshift();\n        parts.push(part);\n        return parts;\n    }\n    getCollission() {\n        const parts = this.getParts(this.location);\n        for (let i = 0, m = parts.length; i < m; i++) {\n            const collision = this.getCollisionPart(i, parts[i]);\n            if (collision) {\n                return collision;\n            }\n        }\n        return null;\n    }\n    getCollisionPart(index, part) {\n        let players;\n        let levelData;\n        let partIndex;\n        players = this.players;\n        levelData = this.level.data;\n        if (index > 4) {\n            partIndex = this.snake.getPartIndex(part);\n            if (-1 !== partIndex && index !== partIndex) {\n                return new Collision(part, CRASH_SELF);\n            }\n        }\n        if (levelData.isWall(part[0], part[1])) {\n            return new Collision(part, CRASH_WALL);\n        }\n        if (levelData.isMovingWall(part)) {\n            return new Collision(part, CRASH_MOVING_WALL);\n        }\n        for (let i = 0, m = players.length; i < m; i++) {\n            const opponentSnake = players[i].snake;\n            if (opponentSnake.crashed === false &&\n                opponentSnake !== this.snake &&\n                opponentSnake.hasPart(part)) {\n                return new Collision(part, CRASH_OPPONENT);\n            }\n        }\n        return null;\n    }\n}\n","import { State } from \"../../client/state/state\";\nimport { ROOM_CAPACITY } from \"../const\";\nimport { Sanitizer } from \"../util/sanitizer\";\nexport class Options {\n    constructor() {\n        this.isQuickGame = false;\n        this.maxPlayers = 6;\n        this.levelset = 0;\n        this.hasPowerups = true;\n        this.isPrivate = false;\n        this.isXSS = false;\n    }\n    destruct() { }\n    serialize() {\n        return [\n            this.maxPlayers,\n            this.levelset,\n            Number(this.isQuickGame),\n            Number(this.hasPowerups),\n            Number(this.isPrivate),\n            Number(this.isXSS),\n        ];\n    }\n    deserialize(serialized) {\n        this.maxPlayers = new Sanitizer(serialized[0])\n            .assertBetween(1, ROOM_CAPACITY)\n            .getValueOr(ROOM_CAPACITY);\n        this.levelset = new Sanitizer(serialized[1])\n            .assertBetween(0, State.levelsetRegistry.levelsets.length - 1)\n            .getValueOr(0);\n        this.isQuickGame = Boolean(serialized[2]);\n        this.hasPowerups = Boolean(serialized[3]);\n        this.isPrivate = Boolean(serialized[4]);\n        this.isXSS = Boolean(serialized[5]);\n    }\n}\n","export class Player {\n    constructor(name = \"\") {\n        this.name = name;\n        this.connected = false;\n        this.score = 0;\n        this.snake = null;\n    }\n    deserialize(serialized) {\n        let byte;\n        [this.name, byte] = serialized;\n        this.connected = Boolean((byte & 1) >> 0);\n        this.local = Boolean((byte & 2) >> 1);\n        this.score = byte >> 2;\n    }\n    serialize(local) {\n        return [\n            this.name,\n            (Number(this.connected) << 0) | (Number(local) << 1) | (this.score << 2),\n        ];\n    }\n}\n","export class PlayerRegistry {\n    constructor() {\n        this.players = [];\n    }\n    destruct() {\n        this.players.length = 0;\n    }\n    serialize(localPlayer) {\n        const serialized = [];\n        for (let i = 0, m = this.players.length; i < m; i++) {\n            serialized.push(this.players[i].serialize(localPlayer === this.players[i]));\n        }\n        return serialized;\n    }\n    add(player) {\n        this.players.push(player);\n    }\n    remove(player) {\n        const index = this.players.indexOf(player);\n        if (-1 !== index) {\n            this.players.splice(index, 1);\n        }\n    }\n    getTotal() {\n        return this.players.length;\n    }\n    isHost(player) {\n        return 0 === this.players.indexOf(player);\n    }\n}\n","export class Snake {\n    constructor(index, level) {\n        this.index = index;\n        const spawn = level.data.spawns[index];\n        /** Head is last in array */\n        this.parts = [spawn.location];\n        this.direction = spawn.direction;\n        this.size = level.config.snakeSize;\n        this.speed = level.config.snakeSpeed;\n        this.crashed = false;\n        this.collision = null;\n        this.gravity = null;\n    }\n    /**\n     * @param {Coordinate} position\n     */\n    move(position) {\n        this.parts.push(position);\n        this.trimParts();\n    }\n    /**\n     * @return {Coordinate}\n     */\n    getHead() {\n        return this.parts[this.parts.length - 1];\n    }\n    hasPartPredict(part) {\n        const treshold = this.crashed ? -1 : 0;\n        return this.getPartIndex(part) > treshold;\n    }\n    trimParts() {\n        while (this.parts.length > this.size) {\n            this.parts.shift();\n        }\n    }\n    hasPart(part) {\n        return -1 !== this.getPartIndex(part);\n    }\n    getPartIndex(part) {\n        const parts = this.parts;\n        for (let i = 0, m = parts.length; i < m; i++) {\n            if (parts[i][0] === part[0] && parts[i][1] === part[1]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    shiftParts(shift) {\n        const x = shift[0] || 0;\n        const y = shift[1] || 0;\n        if (x || y) {\n            for (let i = 0, m = this.parts.length; i < m; i++) {\n                this.parts[i][0] += x;\n                this.parts[i][1] += y;\n            }\n        }\n    }\n    /**\n     * Head-tail switch.\n     */\n    reverse() {\n        let dx;\n        let dy;\n        dx = this.parts[0][0] - this.parts[1][0];\n        dy = this.parts[0][1] - this.parts[1][1];\n        if (dx === 0) {\n            this.direction = dy === -1 ? 1 : 3;\n        }\n        else {\n            this.direction = dx === -1 ? 0 : 2;\n        }\n        this.parts.reverse();\n    }\n}\n","/**\n * @param {Object} obj Object to clone.\n * @return {?} Clone of the input object.\n */\nexport function clone(obj) {\n    const res = {};\n    for (const k in obj) {\n        if (obj.hasOwnProperty(k)) {\n            res[k] = obj[k];\n        }\n    }\n    return res;\n}\n/**\n * @param {Object} target\n * @param {...Object} varArgs\n */\nexport function extend(target, varArgs) {\n    for (let i = 1; i < arguments.length; i++) {\n        const source = arguments[i];\n        for (const k in source) {\n            if (source.hasOwnProperty(k)) {\n                target[k] = source[k];\n            }\n        }\n    }\n}\n// export function filter<Type>(haystack: Type[], needle: Record<string, boolean|string|null>): Type[] {\n//     const filtered = [];\n//     for (let i = 0, m = haystack.length; i < m; i++) {\n//         if (compareProperties(haystack[i], needle)) {\n//             filtered.push(haystack[i]);\n//         }\n//     }\n//     return filtered;\n// }\n//\n// export function compareProperties<Type>(completeObject: Type, subsetObject: Record<string, boolean|string|null>): boolean {\n//     if (completeObject === subsetObject) {\n//         return true;\n//     } else if (subsetObject instanceof Object) {\n//         const keys = Object.keys(subsetObject);\n//         for (let i = 0, l = keys.length; i < l; i++) {\n//             if (!compareProperties(completeObject[keys[i]], subsetObject[keys[i]])) {\n//                 return false;\n//             }\n//         }\n//         return true;\n//     }\n//     return false;\n// }\n/**\n * @param {number} min\n * @param {number} max\n * @return {number}\n */\nexport function randomRange(min, max) {\n    return min + Math.floor(Math.random() * (max - min + 1));\n}\n/**\n * @param {Array} arr\n * @return {?}\n */\nexport function randomArrItem(arr) {\n    return arr[Math.floor(Math.random() * arr.length)];\n}\n/**\n * @param {Array} arr\n * @return {number}\n */\nexport function randomArrIndex(arr) {\n    return Math.floor(Math.random() * arr.length);\n}\n/**\n * @param {number=} len\n * @return {string}\n */\nexport function randomStr(len = 3) {\n    return Math.random().toString(36).substr(2, len);\n}\n/**\n * Ensure an array index is within bounds.\n * @param {number} index\n * @param {Array} arr\n * @return {number}\n */\nexport function ensureIndexWithinBounds(index, arr) {\n    const len = arr.length;\n    if (index >= len) {\n        return 0;\n    }\n    else if (index < 0) {\n        return len - 1;\n    }\n    return index;\n}\nexport function average(numbers) {\n    let total = 0;\n    const m = numbers.length;\n    for (let i = 0; i < m; i++) {\n        total += numbers[i];\n    }\n    return m ? total / m : 0;\n}\n/**\n * @param {Coordinate} a\n * @param {Coordinate} b\n * @return {number}\n */\nexport function delta(a, b) {\n    return Math.abs(a[0] - b[0]) + Math.abs(a[1] - b[1]);\n}\n/**\n * @param {Coordinate} a\n * @param {Coordinate} b\n * @return {boolean}\n */\nexport function eq(a, b) {\n    return a[0] === b[0] && a[1] === b[1];\n}\n/**\n * @param {*} obj\n * @param {*} val\n * @return {?string}\n */\nexport function getKey(obj, val) {\n    for (const k in obj) {\n        if (obj.hasOwnProperty(k) && val === obj[k]) {\n            return k;\n        }\n    }\n    return null;\n}\n/**\n * Faster sorting function.\n * http://jsperf.com/javascript-sort/\n *\n * @param {Array.<number>} arr\n * @return {Array.<number>}\n */\nexport function sort(arr) {\n    for (let i = 1; i < arr.length; i++) {\n        const tmp = arr[i];\n        let index = i;\n        while (arr[index - 1] > tmp) {\n            arr[index] = arr[index - 1];\n            --index;\n        }\n        arr[index] = tmp;\n    }\n    return arr;\n}\n/**\n * @param {number} iterations\n * @param {Function} fn\n * @param {string|number=} label\n */\nexport function benchmark(iterations, fn, label = \"\") {\n    let duration;\n    let i = iterations;\n    const start = +new Date();\n    while (i--) {\n        fn();\n    }\n    duration = +new Date() - start;\n    console.log(label || \"Benchmark\", {\n        x: iterations,\n        avg: duration / iterations,\n        total: duration,\n    });\n}\n/**\n * @return {string}\n */\nexport function getRandomName() {\n    const name = randomArrItem([\n        \"Ant\",\n        \"Bat\",\n        \"Bear\",\n        \"Bird\",\n        \"Cat\",\n        \"Cow\",\n        \"Crab\",\n        \"Croc\",\n        \"Deer\",\n        \"Dodo\",\n        \"Dog\",\n        \"Duck\",\n        \"Emu\",\n        \"Fish\",\n        \"Fly\",\n        \"Fox\",\n        \"Frog\",\n        \"Goat\",\n        \"Hare\",\n        \"Ibis\",\n        \"Kiwi\",\n        \"Lion\",\n        \"Lynx\",\n        \"Miao\",\n        \"Mole\",\n        \"Moth\",\n        \"Mule\",\n        \"Oger\",\n        \"Pig\",\n        \"Pika\",\n        \"Poke\",\n        \"Puma\",\n        \"Puss\",\n        \"Rat\",\n        \"Seal\",\n        \"Swan\",\n        \"Wasp\",\n        \"Wolf\",\n        \"Yak\",\n        \"Zeb\",\n    ]);\n    return name + \".\" + randomRange(10, 99);\n}\n","/**\n * Sanitizer / Sanitize user input.\n * @param {?=} value\n * @constructor\n */\nexport class Sanitizer {\n    constructor(value) {\n        this._value = value;\n        this._valid = true;\n    }\n    /**\n     * @param {string} type\n     * @return {Sanitizer}\n     */\n    assertType(type) {\n        if (typeof this._value !== type) {\n            this._log(\"assertType\", this._value, type);\n            this._valid = false;\n        }\n        return this;\n    }\n    /**\n     * @return {Sanitizer}\n     */\n    assertArray() {\n        if (!(this._value instanceof Array)) {\n            this._log(\"assertArray\", this._value);\n            this._valid = false;\n        }\n        return this;\n    }\n    /**\n     * @return {Sanitizer}\n     */\n    assertJSON() {\n        if (this._valid) {\n            // Don't parse if already invalid\n            try {\n                this._json = JSON.parse(this._value);\n            }\n            catch (err) {\n                this._log(\"assertJSON\", this._value);\n                this._valid = false;\n            }\n        }\n        return this;\n    }\n    /**\n     * @param {Array} arr\n     * @return {Sanitizer}\n     */\n    assertInArray(arr) {\n        if (-1 === arr.indexOf(this._value)) {\n            this._log(\"assertInArray\", this._value, arr);\n            this._valid = false;\n        }\n        return this;\n    }\n    /**\n     * @param {number} min\n     * @param {number} max\n     * @return {Sanitizer}\n     */\n    assertBetween(min, max) {\n        if (typeof this._value !== \"number\") {\n            this._log(\"assertRange type\", this._value);\n            this._valid = false;\n        }\n        else if (this._value < min || this._value > max) {\n            this._log(\"assertRange range\", this._value, min, max);\n            this._valid = false;\n        }\n        return this;\n    }\n    /**\n     *\n     * @return {Sanitizer}\n     */\n    assertIntAsBoolean() {\n        return this.assertBetween(0, 1);\n    }\n    assertStringOfLength(min, max) {\n        max = typeof max === \"undefined\" ? min : max;\n        if (typeof this._value !== \"string\") {\n            this._log(\"assertStringOfLength type\", this._value);\n            this._valid = false;\n        }\n        else if (!this._assertLength(min, max)) {\n            this._log(\"assertStringOfLength length\", this._value, min, max);\n            this._valid = false;\n        }\n        return this;\n    }\n    /**\n     * @param {number} min\n     * @param {number} max\n     * @return {Sanitizer}\n     */\n    assertArrayLengthBetween(min, max) {\n        if (!(this._value instanceof Array)) {\n            this._log(\"assertArrayOfLength type\", this._value);\n            this._valid = false;\n        }\n        else if (!this._assertLength(min, max)) {\n            this._log(\"assertArrayOfLength length\", this._value, min, max);\n            this._valid = false;\n        }\n        return this;\n    }\n    _assertLength(min, max) {\n        return this._value.length >= min && this._value.length <= max;\n    }\n    valid() {\n        return this._valid;\n    }\n    getValueOr(def) {\n        return this._valid ? this._value : def;\n    }\n    /**\n     * @param {*=} def\n     * @return {?}\n     */\n    json(def) {\n        return this._valid ? this._json : def;\n    }\n    /**\n     * @param {string} message\n     * @param {*} value\n     * @param {...*} varArgs\n     * @private\n     */\n    _log(message, value, ...varArgs) {\n        console.warn(\"Validation Error\", message, JSON.stringify(value), varArgs);\n    }\n}\n","'use strict';\n\nmodule.exports = function () {\n  throw new Error(\n    'ws does not work in the browser. Browser clients must use the native ' +\n      'WebSocket object'\n  );\n};\n","module.exports = require(\"events\");;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { Server } from \"./netcode/server\";\nnew Server();\n"],"sourceRoot":""}